# -*- coding: utf-8 -*-
"""Template_mini_projet_SD_MNPI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OrA00rHbijFJiaZVvmM_2cBJj5P7j3sh

# Mini projet : Syst√®mes dynamiques & M√©thodes num√©riques pour l'ing√©nieur

# **Mod√©lisation et dynamique d'une √©pid√©mie, COVID-19 avec et sans confinement -Cas du Maroc-**
**Membres du groupe:**

 * **KADIRI Hiba**      :  Analyse num√©rique / Etude th√©orique du syst√®me avec confinement / R√©sultats et Discussion.
 * **ELHOUARI Nada**    :  Mod√©lisation du probl√®me / Etude th√©orique du syst√®me sans confinement / V√©rification des r√©sultats.
 * **HIRAJI Younes**    :  Etude th√©orique du sys√®me avec confinement.
 * **ELFARSI Latifa**   :  Etude th√©orique du syst√®me avec confinement.
 * **LAABYDY Mohamed**  :  Analyse num√©rique / Etude th√©orique du syst√®me avec confinement / Algorithme et impl√©mentation.

# 0. Mod√©lisation :

Ce projet pr√©sente un mod√®le math√©matique SIR (L'acronyme SIR fait r√©f√©rence aux trois compartiments principaux du mod√®le : Susceptible (S), Infect√© (I) et Retir√© ou R√©tabli (R)) visant √† analyser la dynamique de propagation du Covid-19 tout en prenant en compte l'impact du confinement sur la population susceptible et de l'isolement de la population infectieuse. \\

\
L'un des param√®tres cl√©s que nous √©valuons est le nombre de reproduction de base, $R_0$ , qui repr√©sente le nombre moyen de nouveaux cas engendr√©s par un individu infectieux typique au sein d'une population totalement compos√©e d'individus susceptibles, pendant sa p√©riode d'infection. Cette √©tude se concentre sp√©cifiquement sur le contexte du Maroc en utilisant ledit mod√®le.

**Le mod√®le SIR :** \\
Le mod√®le SIR suppose que la population totale reste constante, ce qui signifie qu'il n'y a pas de naissances ou de d√©c√®s pris en compte. Il utilise des √©quations diff√©rentielles pour d√©crire les taux de changement des populations dans chaque compartiment en fonction de param√®tres tels que le taux de transmission de la maladie et le taux de r√©cup√©ration. \\
\
Ce mod√®le permet d'√©tudier la dynamique de propagation d'une maladie, d'estimer l'impact des interventions (comme la vaccination ou le confinement) et de pr√©voir l'√©volution de l'√©pid√©mie dans une population donn√©e.

Nous proposons un mod√®le SIR qui √©tend le mod√®le classique de Kermack et McKendrick $[4, 5, 6, 1]$  en tenant compte de l'effet du confinement sur les deux populations, les susceptibles et les infectieuses. Nous supposons √©galement que $0 ‚â§ Œ± < 1$  et $0 ‚â§ Œ¥ < 1$  sont les taux de confinement des susceptibles et d'isolement des infectieuses respectivement. Ainsi, la fraction des susceptibles confin√©s (prot√©g√©s) est $Œ±S$ , tandis que la fraction des susceptibles non confin√©s est $(1 ‚àí Œ±) S$ , repr√©sentant la fraction des susceptibles d'√™tre infect√©s par la fraction des infectieuses non confin√©es $(1 ‚àí Œ¥)I$  √† un taux d'infection √©gal √† $Œ¥$ . La fraction $Œ¥I$ est confin√©e. Œõ repr√©sente la densit√© de naissances des susceptibles. La population $R$ comprend les individus retir√©s de la cha√Æne de transmission, y compris ceux confin√©s $(Œ±S)$ , ceux isol√©s $(Œ¥I)$ , les personnes gu√©ries et les personnes d√©c√©d√©es.

\begin{cases}
\frac{dS}{dt}= Œõ- Œ≤(1-Œ±)(1-Œ¥)SI-Œ±S \\
\
\frac{dI}{dt}= Œ≤(1-Œ±)(1-Œ¥)SI-Œ≥I-Œ¥I\\
\frac{dR}{dt}=Œ≥I+Œ±S+Œ¥I \\
\
N=S+I+R= constante ‚Üí si Œõ=0\\
S(0) > 0 , I(0) > 0 , R(0) > 0\\
\end{cases}

####Dans la premi√®re partie on va √©valuer un syst√®me d'√©quation sans confinement.
\begin{cases}
\frac{dS}{dt}=- Œ≤SI\\
\frac{dI}{dt}=Œ≤SI - Œ≥I
\end{cases} \\


####Et dans la deuxi√®me partie on va s'int√©resser √† l'√©volution de la maladie avec confinement.
\begin{cases}
\frac{dS}{dt}=…Ö - Œ≤.(1-Œ±).(1-Œ¥).SI-Œ±.S\\
\frac{dI}{dt}= Œ≤.(1-Œ±).(1-Œ¥).SI - Œ≥I- Œ¥I
\end{cases} \\

# 1. Etude th√©orique (module syst√®me dynamique)

### **1.Evolution de la maladie sans confinement :**

L‚Äô√©tude se fera sur le syst√®me qu‚Äôon a d√©j√† d√©fini pour le cas sans confinement et avec les m√™mes hypoth√®ses (nous supposons que le confinement n‚Äôest pas encore d√©clar√©, Œ± = Œ¥ = 0, nous supposons aussi que le nombre de naissances est n√©gligeable, Œõ = 0) : \\
\begin{cases}
\frac{dS}{dt}=- Œ≤SI\\
\frac{dI}{dt}=Œ≤SI - Œ≥I
\end{cases} \\
En se basant sur des analyses √©pid√©miologiques et des ajustements de mod√®le aux donn√©es observ√©es de l'√©volution de la maladie dans le Maroc,on prend : Œ≤ = 0.17 et Œ≥=0,146 \\
**‚Ä¢	Etude de l‚Äôexistence :** \\
En vertu du th√©or√®me de Cauchy-Lipschitz, nous avons l‚Äôexistence d‚Äôune solution du syst√®me ; √©tudions maintenant les points d‚Äô√©quilibre. \\
**‚Ä¢	Les points d‚Äô√©quilibre et leur stabilit√© :** \\
On a le syst√®me: 
\begin{cases}
\frac{dS}{dt}=- 0,17 SI\\
\frac{dI}{dt}=0,17 SI - 0,146 I
\end{cases} \\
Donc les points d‚Äô√©quilibre sont : (0 ; 0) et (0 ; 0,86)
Etudions maintenant la stabilit√© de ses deux points : \\
On commence par calculer la matrice jacobienne : \\
$J =\begin{pmatrix}
-0,17I & -0,17S  \\
0.17I-0.146 & 0.17S-0.146  \\
\end{pmatrix}$

**Pour le point d'√©quilibre (0 ; 0) :** \\
$J(0,0) =\begin{pmatrix}
0 & 0  \\
-0.146 & -0.146  \\
\end{pmatrix}$ \\
Les valeurs propres de J (0,0) sont les solutions de l'√©quation caract√©ristique $det(J(0,0) - ŒªI) = 0$ , o√π I est la matrice identit√©. \\
En r√©solvant cette √©quation, nous obtenons les valeurs propres suivantes : \\
$Œª_1 = 0 \\
Œª_2 = -0.292$ \\
La valeur propre $Œª_1 = 0$ indique une stabilit√© marginale et la valeur propre $Œª_2 = -0.292$ a une partie r√©elle n√©gative, ce qui indique que le point d'√©quilibre $(0,0)$ est un point d'√©quilibre instable.

**Pour le point d'√©quilibre (0 ; 0,86) :** \\
$J(0,0.86) =\begin{pmatrix}
0 & -0,146  \\
0 & -0.146  \\
\end{pmatrix}$ \\
Les valeurs propres de $J (0,0.86)$ sont les solutions de l'√©quation caract√©ristique $det(J(0,0.86) - ŒªI) = 0$ , avec I la matrice identit√©.\\
En r√©solvant cette √©quation, nous obtenons les valeurs propres suivantes : \\
$Œª_1 = 0 \\
Œª_2 = -0.146$ \\
Donc, le point d'√©quilibre (0,0.86) est un point d'√©quilibre instable avec une stabilit√© marginale le long de la direction associ√©e √† la valeur propre $Œª_1 = 0$.

**Portrait de phase :** \\
Nous allons maintenant tracer le portrait de phase du syst√®me pour visualiser les trajectoires et les comportements des variables dans le plan $(S, I)$.
"""

import numpy as np
import matplotlib.pyplot as plt

# D√©finition des √©quations diff√©rentielles
def dS_dt(S, I):
    return -0.17 * S * I

def dI_dt(S, I):
    return 0.17 * S * I - 0.146 * I

# D√©finition des points d'√©quilibre
def find_equilibrium():
    S_eq = []
    I_eq = []

    # R√©solution des √©quations pour dS_dt = 0 et dI_dt = 0
    for S in np.linspace(0, 1, 100):
        for I in np.linspace(0, 1, 100):
            if abs(dS_dt(S, I)) < 0.01 and abs(dI_dt(S, I)) < 0.01:
                S_eq.append(S)
                I_eq.append(I)

    return S_eq, I_eq

# Calcul des points d'√©quilibre
S_eq, I_eq = find_equilibrium()

# Plage de valeurs de S et I
S = np.linspace(0, 1, 20)
I = np.linspace(0, 1, 20)

# Cr√©ation de la grille de valeurs
S, I = np.meshgrid(S, I)

# Calcul des d√©riv√©es dS et dI sur la grille de valeurs
dS = dS_dt(S, I)
dI = dI_dt(S, I)

# Trac√© des portraits de phase avec fl√®ches vers les points d'√©quilibre
plt.quiver(S, I, dS, dI)
plt.scatter(S_eq, I_eq, color='red')
plt.xlabel('S')
plt.ylabel('I')
plt.title('Portrait de phase du syst√®me')

# Ajout des fl√®ches
for i in range(len(S_eq)):
    plt.annotate("", xy=(S_eq[i], I_eq[i]), xytext=(S_eq[i]+0.1, I_eq[i]), arrowprops=dict(arrowstyle="->", lw=1.5))

plt.grid()
plt.show()

"""### **2.Evolution de la maladie avec confinement :**

Dans ce paragraphe, nous examinons le mod√®le $(1.1)$ avec les param√®tres de confinement $Œ±>0$ et $Œ¥>0$ . \\
Nous nous concentrons sur l'√©tude du syst√®me SI car la population du compartiment R depend des population $S$ et $I$ , tel que $S$ et $I$ independents de $R$ . \\
Supposons que $Œõ>0$ pour prendre en compte les nouvelles naissances pendant la dur√©e de l'√©pid√©mie. \\
Le syst√®me de d√©part devient : \\
\begin{cases}
\frac{dS}{dt}=…Ö - Œ≤.(1-Œ±).(1-Œ¥).SI-Œ±.S\\
\frac{dI}{dt}= Œ≤.(1-Œ±).(1-Œ¥).SI - Œ≥I- Œ¥I
\end{cases} \\
En tenant compte de la dynamique de propagation du coronavirus au Maroc avec confinement, les valeurs de Œ≤ et Œ≥  ont √©t√© choisies pour mod√©liser une transmission relativement intense du virus et un taux de gu√©rison moyen : \\
$Œ≤=1.25$ et $Œ≥=1$

####**Point d'√©quilibre du syst√®me :** 
On r√©sout ce syst√®me alg√©brique. on annule les d√©riv√©es de $S(t)$ et de $I(t)$ . \\
On constate deux cas : \\

**Le point d'√©quilibre sans maladie :** \\
On a $I(t) = 0 $ , $ \frac{dS}{dt}=0 $, $\frac{dI}{dt}=0$ \\
$Œõ-Œ≤(1-Œ±)(1_Œ¥).0.I- Œ±S = 0$ \\
‚áí $S=\frac{Œõ}{Œ±}$ \\
D'o√π le point d'√©quilibre est $E_0=(\frac{Œõ}{Œ±},0)$

**Le point d'√©quilibre avec maladie:** \\
$ \frac{dS}{dt}=0 $, $\frac{dI}{dt}=0$ \\

\begin{cases}
Œõ-Œ≤(1-Œ±)(1_Œ¥).S^{\ast}.I^{\ast} Œ±S^{\ast} = 0 \\
Œ≤(1-Œ±)(1-Œ¥)S^{\ast}.I^{\ast} - Œ±S^{\ast} - Œ≥I^{\ast} - Œ¥I^{\ast} = 0
\end{cases} \\

\begin{cases}
S^{\ast}=\frac{Œ≥+Œ¥}{Œ≤.(1-Œ±).(1-Œ¥)}\\ 
\\
I^{\ast}=\frac{Œõ-Œ±.S^{\ast}}{Œ≤.(1-Œ±).(1-Œ¥).S^{\ast}} = \frac{Œõ-Œ±.S^{\ast}}{Œ≥+Œ¥} 
\end{cases} \\

d'o√π $E^{\ast}=(S^{\ast},I^{\ast})$ \\
$E^{\ast}$ est positif si $Œõ-Œ±.S^{\ast} > 0$ \\
‚áí $ Œõ > \frac{Œ±(Œ≥+Œ¥)}{Œ≤(1-Œ±)(1-Œ¥)} $ \\
\
‚áí $ \frac{Œ≥Œ≤(1-Œ±)(1-Œ¥)}{Œ≥+Œ¥} > 1 $ \\
\
Posons $R_0=\frac{Œ≥Œ≤(1-Œ±)(1-Œ¥)}{Œ≥+Œ¥}$

On fait la disjonction des deux cas : $R_0 < 1$ et $R_0 > 1$.

**Premier cas: suposons que $R_0  < 1$ , alors:** \\

on a $E^{\ast}$ est n√©gatif, donc $E^{\ast}$ n'existe pas \\
donc le point d'√©quilibre sans maladie $E_0$ est le seul point d'√©quilibre du syst√®me.\\
**Etudions la stabilit√© de $E_0$ : ** \\
d'abord calculons la jacobienne: \\

$J(E)=\begin{pmatrix}
\ - Œ≤(1- Œ±)(1- Œ¥)I-Œ± &  -Œ≤(1- ùõÇ)(1-Œ¥)S \\
Œ≤(1-Œ±)(1-Œ¥)I & Œ≤(1-Œ±)(1-Œ¥)S-Œ≥-Œ¥ \\
\end{pmatrix}$ \\
\
calculons $J(E_0)$: \\
$J(E_0)=\begin{pmatrix}
\ -Œ± & \frac{-Œ≤(1-Œ±)(1-Œ¥)ùö≤}{Œ±} \\
0 &  \frac{Œ≤(1-Œ±)(1-Œ¥)ùö≤}{Œ±} - Œ≥ -Œ¥ \\
\end{pmatrix}$ \\
le polynome caract√©ristique de cette matrice: 
det(ŒªI-J($E_0$)) a pour solutions: \\
 $Œª_1=-Œ±$ \\

 $Œª_2 = \frac{Œ≤(1-Œ±)ùö≤}{Œ±}-Œ≥-Œ¥ $ \\
$Œª_1<0$ et $Œª_2<0$ \\
donc le point d'√©quilibre $E_0$ est localement asymptotiquement stable

**Deuxieme cas: supposons que $R_0>1$, alors:** \\
-Il est √©vident que le point d'√©quilibre sans maladie $E_0$ est instable  \\
-Pour le point d'√©quilibre avec maladie; \\
calculons la jacobienne de $E^{\ast}$ \\
$J(E^{\ast}) =\begin{pmatrix}
\ -Œ≤(1-Œ±)(1-Œ¥)I^{\ast}-Œ± & -(Œ≥+Œ¥) \\
Œ≤(1-Œ±^)(1-Œ¥)I^{\ast} & 0 \\
\end{pmatrix}$  \\
\
Comme $tr(J(E^{\ast})) < 0$ et $det(J(E^{\ast}))>0$ \\

\

donc $E^{\ast}$ est un point d'√©quilibre localement asymptotiquement stable.

**Portrait de phase :** \\
Dans cette partie nous allons tracer le portrait de phase de notre syst√®me.
"""

import numpy as np
import matplotlib.pyplot as plt

# D√©finir les param√®tres du syst√®me
alpha = 0.2
beta = 0.5
gamma = 0.3
delta = 0.1
…Ö = 1
# D√©finir les √©quations diff√©rentielles du syst√®me
def dS_dt(S, I):
    return …Ö - beta * (1 - alpha) * (1 - delta) * S * I - alpha * S

def dI_dt(S, I):
    return beta * (1 - alpha) * (1 - delta) * S * I - gamma * I - delta * I

# D√©finir les points d'√©quilibre
equilibrium_points = [(…Ö / (beta * (1 - alpha) * (1 - delta))), (…Ö / (beta * (1 - alpha) * (1 - delta) * gamma + delta))]

# D√©finir la fonction pour calculer les d√©riv√©es des variables
def derivatives(variables, t):
    S, I = variables
    dSdt = dS_dt(S, I)
    dIdt = dI_dt(S, I)
    return [dSdt, dIdt]

# D√©finir les valeurs pour la grille du portrait de phase
S_values = np.linspace(0, 2, 20)
I_values = np.linspace(0, 2, 20)

# Cr√©er la grille du portrait de phase
S_grid, I_grid = np.meshgrid(S_values, I_values)

# Calculer les d√©riv√©es sur la grille
dSdt_grid, dIdt_grid = derivatives([S_grid, I_grid], 0)

# Tracer le portrait de phase
plt.figure(figsize=(8, 6))
plt.quiver(S_grid, I_grid, dSdt_grid, dIdt_grid, scale=20)
plt.xlabel('S')
plt.ylabel('I')
plt.title('Portrait de phase')
plt.grid()
plt.xlim([0, 2])
plt.ylim([0, 2])


# D√©finir les points d'√©quilibre
equilibrium_points = [(…Ö / (beta * (1 - alpha) * (1 - delta))), (…Ö / (beta * (1 - alpha) * (1 - delta) * gamma + delta))]

# Tracer les points d'√©quilibre
for point in equilibrium_points:
    plt.plot(point, 0, 'ro')
    plt.text(point, 0, f'({point:.2f}, 0)', ha='center', va='bottom')


# Afficher le graphique
plt.show()

"""# 2. Analyse num√©rique (module m√©thode num√©rique pour l‚Äôing√©nieur)

Le probl√®me s'√©crit :
\begin{cases}
\frac{dS}{dt}=…Ö - Œ≤.(1-Œ±).(1-Œ¥).SI-Œ±.S\\
     S(0)=N
\end{cases}

**Pour le sch√©ma d'Euler explicite:**

Soit h le pas du temps. \\
$ S(t_n+h)=S(t_n)+h.\dot{S}(t_n)
= S(t_n)+h.(…Ö - Œ≤.(1-Œ±).(1-Œ¥).S(t_n)I-Œ±.S(t_n))\\
= S(t_n).(…Ö-hA-hŒ±)+h…Ö$ \\
avec  $A= Œ≤.(1-Œ±).(1-Œ¥).I$

$S_1= S_0(1-hA-hŒ±)+h…Ö \\
S_2= S_1(1-hA-hŒ±)+h…Ö \\
S_2= S_0(1-hA-hŒ±)^2 +h…Ö(1-hA-hŒ±)+ h…Ö \\
S_3= S_0(1-hA-hŒ±)^3 +h…Ö(1-hA-hŒ±)^2+ h…Ö(1-hA-hŒ±)+ h…Ö \\ $

Alors on trouve l'expression r√©currente suivante: \\
$ S_n=S_0(1-hA-hŒ±)^n + \sum_{k=0}^{n-1} h…Ö(1-hA-hŒ±)^k $ \\
C'est le sch√©ma d'Euler explicite.

On perturbe la condition initiale $S_0$ avec $SÃÉ_0=S_0+œµ$ \\
$ SÃÉ=(S_0+œµ).(1-Ah-hŒ±)^n + \sum_{k=0}^{n-1} h…Ö(1-hA-hŒ±)^k \\
= S_n + œµ(1-hA-hŒ±)^n $ \\
Alors $ | SÃÉ_n - S_n |= œµ|1-hA-hŒ±|^n $ avec $ œµ > 0$ \\
Le sch√©ma d'Euler reste stable apr√®s perturbation de la donn√©e initiale lorsque \\ $|1- Ah - Œ± h |^n < 1 $ \\
c-√†-d $ 0 < h < \frac{2}{A+Œ±} $ \\
Pour √©tudier la convergence de ce sch√©ma, nous devons v√©rifier si la solution numerique $S_n$ converge vers la solution exacte $y$ lorsque le pas h tend vers 0. \\
L'erreur: $ œµ=y-S_n $ \\
Or le sch√©ma d'Euler  explicite a une convergence d'ordre 1, d'o√π cela signifie que $ œµ(t)= ùôæ(h) $ alors on peut d√©duire que $\lim_{h \to a} œµ = 0 $ \\
Et par suite le sch√©ma est convergent.

La condition de stabilit√© nous a permis de choisir une valeur de $h = 1$ \\
Le sch√©ma d'Euler explicite peut √™tre repr√©sent√© comme suit :
"""

import numpy as np
import matplotlib.pyplot as plt

def euler_explicit(A, alpha, N, n, h,…Ö):
    S = np.zeros(n+1)
    S[0] = N
    
    for k in range(n):
        S[k+1] = S[k] + h * (…Ö - A*S[k] - alpha*S[k])
    
    return S

# Param√®tres du syst√®me
…Ö = 1
A = 2
alpha = 0.5
N = 34000000
n = 200
h = 1

# Calcul du sch√©ma d'Euler explicite
S = euler_explicit(A, alpha, N, n, h,…Ö)

# Trac√© du sch√©ma d'Euler explicite
t = np.arange(0, n+1) * h
plt.plot(t, S)
plt.xlabel('Temps')
plt.ylabel('Population (S)')
plt.title('Sch√©ma d\'Euler explicite')
plt.show()

"""**Pour le sch√©ma d'Euler implicite:**

Soit h le pas du temps.
\begin{cases}
S(t_n+h)=S(t_n)+h(…Ö - Œ≤.(1-Œ±).(1-Œ¥).SI-Œ±.S) \\
     S(t_0)=N
\end{cases} \\

‚áí
\begin{cases}
(1+Ah+Œ±h) S_{n+1} = S_n +h…Ö \\
     S(t_0)=N
\end{cases} \\

‚áí $ S_{n+1} = \frac{S_n}{1+Ah+Œ±h} +\frac{h…Ö}{1+Ah+Œ±h} $

$ S_1 = \frac{S_0}{1+Ah+Œ±h} +\frac{h…Ö}{1+Ah+Œ±h} $ \\
$ S_2 = \frac{S_1}{1+Ah+Œ±h} +\frac{h…Ö}{1+Ah+Œ±h} $ \\
$ S_2 = \frac{S_0}{(1+Ah+Œ±h)^2} +\frac{h…Ö}{(1+Ah+Œ±h)^2} +\frac{h…Ö}{1+Ah+Œ±h} $ \\
D'o√π on d√©duit l'expression r√©currente du sch√©ma implicite: \\

$ S_n = \frac{S_0}{(1+Ah+Œ±h)^n} +‚àë_{k=1}^n \frac{h…Ö}{(1+Ah+Œ±h)^k} $ \\
‚áí
C'est le sch√©ma d'Euler implicite.

**Etude de la convergence :** \\
L'objectif est de v√©rifier si $S_n$ converge vers la solution exacte du syst√®me lorsque h ‚Üí 0 . \\
on tend h vers 0 : \\
$\lim_{h \to 0} S_n = \lim_{h \to 0} \frac{S_0}{(1+Ah+Œ±h)^n} +\lim_{h \to 0} ‚àë_{k=1}^n \frac{h…Ö}{(1+Ah+Œ±h)^k} $ \\
$ = S_0 + 0 = S_0 $ \\
Lorsque h tend vers 0, le sch√©ma d'Euler implicite converge bien vers la valeur initiale $S_0$. \\
On d√©duit que ce sch√©ma est convergent.
"""

import numpy as np
import matplotlib.pyplot as plt

# D√©finition des param√®tres
A = 2
alpha = 0.5
N = 34000000
h = 0.1
n = 200
…Ö = 1 
# D√©finition de la fonction f(S) = 1 - AS - alpha*S
def f(S):
    return …Ö - A*S - alpha*S

# Sch√©ma d'Euler implicite
def euler_implicit(S0, h, n,…Ö):
    S = [S0]  # Liste pour stocker les valeurs de S
    for i in range(1, n+1):
        S.append(S[i-1] / (1 + h*A + alpha*h) + h*f(S[i-1]))
    return S

# Calcul des valeurs de S en utilisant le sch√©ma d'Euler implicite
S_values = euler_implicit(N, h, n,…Ö)

# Cr√©ation du vecteur temps
t = np.linspace(0, n*h, n+1)

# Trac√© de la solution obtenue
plt.plot(t, S_values, label='Euler implicite')
plt.xlabel('Temps')
plt.ylabel('S')
plt.title('Sch√©ma d\'Euler implicite')
plt.legend()
plt.show()

"""### **Nous pr√©f√©rons utiliser le sch√©ma explicite en raison de sa pr√©cision sup√©rieure. Les sch√©mas explicites offrent un contr√¥le pr√©cis de la pr√©cision en ajustant le pas de temps. En augmentant le nombre d'it√©rations ou en r√©duisant le pas de temps, nous pouvons obtenir des r√©sultats plus pr√©cis. Cela nous permet de r√©pondre aux exigences sp√©cifiques du probl√®me et d'obtenir une pr√©cision plus √©lev√©e lorsque n√©cessaire. De plus, la simplicit√© de mise en ≈ìuvre des sch√©mas explicites facilite l'ajustement du pas de temps et la gestion de la pr√©cision. Par cons√©quent, compte tenu de l'importance que nous accordons √† la pr√©cision des r√©sultats, nous optons pour le sch√©ma explicite.**

# 3. Impl√©mentation (Code Python)
"""

import numpy as np
from scipy.integrate import odeint
import time
import matplotlib.pyplot as plt

"""**L'algorithme propos√© pour la r√©solution du syst√®me :**"""

def euler_explicit_solver(A, alpha, N, n, h):
    S = np.zeros(n+1)
    S[0] = N
    
    for k in range(n):
        S[k+1] = S[k] + h * (1 - A*S[k] - alpha*S[k])
    
    return S

"""**pour comparer cette m√©thode avec la fonction odeint de la biblioth√®que SciPy**"""

def odeint_solver(A, alpha, N, t):
    def system(S, t):
        return …Ö - A*S - alpha*S
    
    S0 = N
    S = odeint(system, S0, t)
    
    return S.flatten()

# Param√®tres du syst√®me
A = 2
alpha = 0.5
N = 34000000
n = 200
h = 0.1
…Ö = 1

# Temps d'√©chantillonnage
t = np.arange(n+1) * h

# R√©solution avec Euler explicite
start_time = time.time()
S_euler = euler_explicit_solver(A, alpha, N, n, h)
euler_time = time.time() - start_time

# R√©solution avec odeint
start_time = time.time()
S_odeint = odeint_solver(A, alpha, N, t)
odeint_time = time.time() - start_time

# Comparaison des r√©sultats
error = np.abs(S_euler - S_odeint)

print("Erreur maximale : ", np.max(error))
print("Temps de calcul (Euler explicite) : ", euler_time)
print("Temps de calcul (odeint) : ", odeint_time)

"""## **Commentaire :** 
Dans ce script, nous utilisons la fonction odeint de la biblioth√®que SciPy pour r√©soudre le syst√®me diff√©rentiel. Nous comparons ensuite les r√©sultats obtenus avec les deux m√©thodes (Euler explicite et odeint) en calculant l'erreur maximale entre les deux solutions num√©riques. De plus, nous mesurons √©galement le temps de calcul pour chaque m√©thode.

## **Comparaison graphique :** 
Nous tra√ßons parla suite les solutions obtenues avec les m√©thodes d'Euler explicite et odeint sur le m√™me graphique. \\
Les solutions sont trac√©es en fonction du temps (t) et de la population (S).
"""

# Trac√© des solutions
plt.plot(t, S_euler, label='Euler explicite')
plt.plot(t, S_odeint, label='odeint')
plt.xlabel('Temps')
plt.ylabel('Population (S)')
plt.title('Comparaison des solutions : Euler explicite vs odeint')
plt.legend()
plt.show()

"""# 4. Discussion

En r√©sum√©,  ce projet examine le r√¥le du confinement de la population susceptible et de l'isolement de la population infectieuse dans la gestion de la propagation des √©pid√©mies, en mettant particuli√®rement l'accent sur le **Covid-19 au Maroc**. L'√©tude analyse l'impact du nombre de reproduction de base, un facteur cl√© dans la transmission des √©pid√©mies. Pour traiter ce probl√®me nous avons compar√© les deux p√©riodes, avant et apr√®s confinement : la p√©riode avant confinement marqu√©e par l'apparition des cas locaux, et la p√©riode apr√®s confinement (√† partir du 20 mars), caract√©ris√©e par la propagation plus large de l'√©pid√©mie au sein de la population. \\


Les r√©sultats d√©montrent que pendant la phase initiale, le nombre cumulatif de personnes infect√©es augmente automatiquement. Cependant, lors de la phase ult√©rieure et gr√¢ce √† la mise en place de mesures de confinement et d'isolement, le taux de transmission diminue par rapport √† la phase initiale. Il est soulign√© que le nombre de reproduction de base est influenc√© par les taux de confinement et d'isolement. Une augmentation de ces taux conduit √† une diminution du nombre de reproduction en dessous de 1, ce qui indique un contr√¥le r√©ussi de l'√©pid√©mie, tandis que des taux plus bas conduisent √† un nombre de reproduction sup√©rieur √† 1, ce qui signifie une propagation continue de la maladie. \\


**En conclusion, la gestion efficace d'une √©pid√©mie repose sur la capacit√© √† r√©guler les taux de confinement pour la population susceptible et d'isolement pour les personnes infect√©es.**
"""